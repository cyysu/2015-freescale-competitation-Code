//------------------------------------------------------------------------
//  Readme.txt
//------------------------------------------------------------------------
This project is configure to get you up and running quickly using 
CodeWarrior with the Freescale MCF52259 board.

This project provides full support for the selected board.
The created project provides Standard IO Support through console and terminal window.

Sample code for the following language:
- C


//------------------------------------------------------------------------
// Memory Maps
//------------------------------------------------------------------------
The Hardware has the following memory map:

# MCF52259 Derivative Memory map definitions from linker command files:
# __IPSBAR, __RAMBAR, __RAMBAR_SIZE, __FLASHBAR, __FLASHBAR_SIZE linker
# symbols must be defined in the linker command file.

# Memory Mapped Registers (IPSBAR= 0x40000000)
   ___IPSBAR         = 0x40000000;

# 32 Kbytes Internal SRAM
   ___RAMBAR         = 0x20000000;
   ___RAMBAR_SIZE    = 0x0000FFFF;

# 512 KByte Internal Flash Memory
   ___FLASHBAR       = 0x00000000;
   ___FLASHBAR_SIZE  = 0x00080000;



//------------------------------------------------------------------------
// Project Structure
//------------------------------------------------------------------------
The project generated contains various files/groups:
- readme.txt: information for this project
- Sources: application source codes, user customizable startup 
  code, uart library, exception table
- Includes: derivative and board header files, ... 
- Libs: runtime and libs 
- Project Settings: linker command files for the different build 
  targets, the initialization and memory configuration files for 
  the hardware debugging, the common startup code, etc...
  
//------------------------------------------------------------------------
// Build Targets
//------------------------------------------------------------------------
- CONSOLE_INTERNAL_RAM:
This project target is setup to load and debug code from internal RAM.
It should be used during your application development.
The application outputs to the CodeWarrior's console window.

- INTERNAL_RAM:
This project target is setup to load and debug code from internal RAM.
It should be used during your application development.
This is the very basic project that outputs to the UART.
You needs to connect a Terminal Program to see the output.

- INTERNAL_FLASH:
This project target is setup to load and debug code in Internal FLASH.
This is the very basic project that outputs to the UART. User needs
to connect the terminal to see the output.



===================================================================
WARNING regarding debugging new project wizard code with CCS-SIM
===================================================================
The CCS-SIM is an instruction set simulator, it does not implement
any peripherals.
The new project generated by the wizard are using startup code 
performing some hardware peripheral initializations.
When debugging with the CCS-SIM  it might happen that the simulation
stuck on loop using non implemented peripheral register flag as 
condition (PLL initialization as example).  
In this case, you should either:
- move the PC to next statement
- use a skip point
- define a simulator specific macro which used when define allos you 
to comment out the unwanted code in order to debug with CCS-SIM
 

===================================================================
WARNING regarding code located in RAM
===================================================================
Many possible ColdFire target processors have an external bus, so 
you can use large external RAM devices for debugging applications 
during development. But some processors do not have an external 
bus, so you must accommodate applications in on-chip memory. 
Although this on-chip RAM accommodates this CodeWarrior project, 
it probably is too small for full development of your application. 
Accordingly, for a processor without external bus, you should locate 
your applications in flash memory. 

//------------------------------------------------------------------------
//  Flashing the code
//------------------------------------------------------------------------
1. Select the appropriate project target and build it
2. Make sure the correct remote connection is selected in the Remote 
   Connection debugger panel
3. In the CodeWarrior IDE menu, select Project > Set Default Project 
   and select your project
4. In the CodeWarrior IDE menu, select Project > Set Default Target 
   and select the project target that has the code you want to flash
5. In the CodeWarrior IDE menu, select Tools > Flash Programmer
6. Go to the flash programmer Target Configuration panel, click Load 
   Settings 
7. Browse to the <your project location>\cfg sub folder and
   select the flash settings xml file matching your build target 
8. Check that Use Custom Settings checkbox is not selected
9. Go to the Erase/Blank Check panel, select the All Sectors option and 
   click Erase
10. Go to Program/Verify panel, click Program
11. Your code should now be flashed

//------------------------------------------------------------------------
// Terminal Settings
//------------------------------------------------------------------------
In case the UART is supported, the terminal should be setup with:
- 19200 bauds,
- 8 data bits,
- no parity,
- 1 stop bit,
- no flow control.

Please check this file in the project.

//------------------------------------------------------------------------
//  Getting Started
//------------------------------------------------------------------------
To build/debug your project, use the CodeWarrior IDE menu Project > Debug 
or press F5. This will launch the debugger. Press again F5 in the 
debugger (or the CodeWarrior IDE menu Project > Run) to start the 
application. The CodeWarrior IDE menu Project > Break stops the 
application.

//------------------------------------------------------------------------
//  Adding your own code
//------------------------------------------------------------------------
Once everything is working as expected, you can begin adding your own code
to the project. Keep in mind that we provide this as an example of how to
get up and running quickly with CodeWarrior. There are certainly other
ways to handle interrupts and set up your linker command file. Feel free
to modify any of the source files provided.

//------------------------------------------------------------------------
//  Additional documentation
//------------------------------------------------------------------------
Read the online documentation provided. In CodeWarrior IDE menu, select
Help > CodeWarrior Help.

//------------------------------------------------------------------------
//  Contacting Freescale
//------------------------------------------------------------------------
For bug reports, technical questions, and suggestions, please use the
forms installed in the Release_Notes folder.


































/*
	temp=(int16)pian_cha;
		if(temp>=0)
		{
			
		uart1_putchar(' ');
		uart1_putchar(' ');
		}
		else
		{
		uart1_putchar(' ');
		uart1_putchar('-');
		
		temp=-temp;
			
		}
		ge=temp%10+0x30;
		shi=temp%100/10+0x30;
		bai=temp%1000/100+0x30;
		qian=temp%10000/1000+0x30;
		wan=temp/10000+0x30;
		
	//	uart0_putchar(255);

		uart1_putchar(wan);
	    uart1_putchar(qian);
	    uart1_putchar(bai);
	    uart1_putchar(shi);
	    uart1_putchar(ge);
	    uart1_putchar('\n');
	 


		 temp=(int16)checkdown5;
		if(temp>=0)
		uart1_putchar(' ');
		else
		{
		uart1_putchar('-');
		temp=-temp;	
		}
		ge=temp%10+0x30;
		shi=temp%100/10+0x30;
		bai=temp%1000/100+0x30;
		qian=temp%10000/1000+0x30;
		wan=temp/10000+0x30;
		
	//	uart0_putchar(255);

		uart1_putchar(wan);
	    uart1_putchar(qian);
	    uart1_putchar(bai);
	    uart1_putchar(shi);
	    uart1_putchar(ge);
	    uart1_putchar('\n');
/*/
	 /*   temp=(int16)g_fLeftMotorOut;
		if(temp>=0)
		uart0_putchar(' ');
		else
		{
		uart0_putchar('-');
		temp=-temp;	
		}
		ge=temp%10+0x30;
		shi=temp%100/10+0x30;
		bai=temp%1000/100+0x30;
		qian=temp%10000/1000+0x30;
		wan=temp/10000+0x30;
		
	//	uart0_putchar(255);

		uart0_putchar(wan);
	    uart0_putchar(qian);
	    uart0_putchar(bai);
	    uart0_putchar(shi);
	    uart0_putchar(ge);
	    uart0_putchar('\n');
	    */





















/**
void MotorOutput(void)   //8us左右   原来好像有错误，方向判断应是实际值，只是理论的值，没把调节两轮转速相同值考虑进去，现在程序是经过改正的
{
    int16 Left_run=0,Right_run=0,baohu=0;
    g_fLeftMotorOut  = g_fAngleControlOut;// -  gf_SpeedControlOut - gf_Left_DirectionControlout;
    g_fRightMotorOut = g_fAngleControlOut;// -  gf_SpeedControlOut - gf_Right_DirectionControlout;
      
	if(g_fLeftMotorOut> 0)     
		g_fLeftMotorOut += MOTOR_OUT_DEAD_VAL_L;
	else if(g_fLeftMotorOut < 0)   
	    g_fLeftMotorOut -= MOTOR_OUT_DEAD_VAL_L;
	if(g_fRightMotorOut > 0)    
	    g_fRightMotorOut += MOTOR_OUT_DEAD_VAL_R;
	else if(g_fRightMotorOut < 0)  
	    g_fRightMotorOut -= MOTOR_OUT_DEAD_VAL_R;
    
    if(g_fLeftMotorOut > MOTOR_OUT_MAX)
        g_fLeftMotorOut = MOTOR_OUT_MAX;
    if(g_fLeftMotorOut < MOTOR_OUT_MIN)
        g_fLeftMotorOut = MOTOR_OUT_MIN;
    if(g_fRightMotorOut > MOTOR_OUT_MAX)
        g_fRightMotorOut = MOTOR_OUT_MAX;
    if(g_fRightMotorOut < MOTOR_OUT_MIN)
        g_fRightMotorOut = MOTOR_OUT_MIN;
	
    Left_run  = (int16)(g_fLeftMotorOut );
    Right_run = (int16)(g_fRightMotorOut);
    
    
    
    /**
    if(Left_run>=0)
    {
    	PWM_leftfront(Left_run);		
    }
    else
    {
    	Left_run = -Left_run;
    	PWM_leftback(Left_run);
    }
    if(Right_run>=0)
    {
    	PWM_rightfront(Right_run);	
    }
    else
    {
    	Right_run=-Right_run;
    	PWM_rightback(Right_run);		
    }  
     
}
 **/ 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
/***
void dma_init()
{
	MCF_GPIO_PTJPAR=0;
	MCF_GPIO_DDRTJ=0;
	//MCF_DMA_DCR(0)=0X00;
	MCF_DMA_DSR(0)|=MCF_DMA_DSR_DONE;
	//MCF_DMA_DCR(0)&=~MCF_DMA_DCR_EEXT;
	MCF_SCM_MPR=MCF_SCM_MPR_MPR(0X05);
	MCF_SCM_DMAREQC=MCF_SCM_DMAREQC_DMAC0(0X05);
	MCF_DMA_SAR(0)=(uint32)0x40100036;
	MCF_DMA_DAR(0)=(uint32)Pix_Data;
	MCF_DMA_BCR(0)=H;
	MCF_DMA_DCR(0)=//MCF_DMA_DCR_INT
	              MCF_DMA_DCR_SSIZE(1)
	              |MCF_DMA_DCR_DSIZE(1)
	              |MCF_DMA_DCR_DINC
	              |MCF_DMA_DCR_D_REQ          
	              |MCF_DMA_DCR_CS;
	             
	MCF_GPIO_PTCPAR|=MCF_GPIO_PTCPAR_DTIN1_DTIN1;
	//MCF_GPIO_DDRTC=0X00;
	//MCF_GPIO_PORTTC=0XFF;
	MCF_DTIM_DTMR(1)=0;//重置STMR寄存器
	MCF_DTIM1_DTER|=MCF_DTIM_DTER_REF;
	MCF_DTIM_DTMR(1)=MCF_DTIM_DTMR_CE_FALL
	                |MCF_DTIM_DTMR_CLK_DTIN;
	MCF_DTIM_DTER(1)|=MCF_DTIM_DTER_CAP;//边沿捕捉触发
	MCF_DTIM_DTXMR(1)|=MCF_DTIM_DTXMR_DMAEN;
	MCF_INTC0_IMRL&=~MCF_INTC_IMRL_MASKALL;
	//MCF_INTC0_IMRL&=~MCF_INTC_IMRL_INT_MASK9;
	MCF_INTC0_ICR09=MCF_INTC_ICR_IP(3)+MCF_INTC_ICR_IL(7);
	MCF_DTIM_DTMR(1)|=MCF_DTIM_DTMR_RST;
	//MCF_DMA_DCR(1)|=MCF_DMA_DCR_EEXT;
					   

}

///电机右边编码器
void right_dma_counter_init()
{
	MCF_GPIO_PTCPAR|=MCF_GPIO_PTCPAR_DTIN3_DTIN3;
	MCF_DTIM_DTMR(3) = 0;//重置STMR寄存器
	MCF_DTIM_DTMR(3) = MCF_DTIM_DTMR_CE_RISE
	                  |MCF_DTIM_DTMR_CLK_DTIN;
	MCF_DTIM_DTER(3)|=MCF_DTIM_DTER_CAP;//边沿捕捉触发
	MCF_DTIM_DTMR(3)|=MCF_DTIM_DTMR_RST;
}
uint16 right_dma_counter()
{
	uint32 counter=0;
	counter = MCF_DTIM3_DTCN;
	MCF_DTIM3_DTCN = 0;
	return counter;
}


///电机左边编码器
void left_dma_counter_init()
{
	MCF_GPIO_PTCPAR |= MCF_GPIO_PTCPAR_DTIN1_DTIN1;
	MCF_DTIM_DTMR(1) = 0;//重置STMR寄存器
	MCF_DTIM_DTMR(1) = MCF_DTIM_DTMR_CE_RISE
	                  |MCF_DTIM_DTMR_CLK_DTIN;
	MCF_DTIM_DTER(1)|= MCF_DTIM_DTER_CAP;//边沿捕捉触发
	MCF_DTIM_DTMR(1)|= MCF_DTIM_DTMR_RST;
}
uint32 left_dma_counter()
{
	uint32 counter = 0;
	counter = MCF_DTIM1_DTCN;
	MCF_DTIM1_DTCN=0;
	return counter;
}

****/

/***
void DmaUartTxinit()
{
	MCF_SCM_MPR|=0X04;	//使能DMA控制器
	MCF_SCM_DMAREQC|=MCF_SCM_DMAREQC_DMAC0(0x0C);//uart0发送对应通道0
	MCF_UART0_UIMR=0X02;	//设置UART中断屏蔽寄存器中的中断使能位
	MCF_INTC0_IMRL|=MCF_INTC_IMRL_INT_MASK9;//通道0中断源是9
}

void DmaUartTxStrt(uint8 * seBuff,uint16 buffSize)
{
//	DmaUartTxinit();
	MCF_DMA_DSR(0)=MCF_DMA_DSR_DONE;
	MCF_DMA_SAR(0)=(uint32)seBuff;
	MCF_DMA_DAR(0)=(uint32)&MCF_UART0_UTB;
	MCF_DMA_BCR(0)=buffSize;
	MCF_DMA_DCR(0)=(MCF_DMA_DCR_EEXT
			//	   |MCF_DMA_DCR_CS
				   |MCF_DMA_DCR_AA
				   |MCF_DMA_DCR_SINC
				   |MCF_DMA_DCR_SSIZE(01)
				   |MCF_DMA_DCR_DSIZE(01));
	MCF_DMA_DCR(0)|=MCF_DMA_DCR_START;
}





**/	 




	/** 测试串口**/
		//  uart0_putchar('t');
		
		/** 测试蜂鸣器**/  
		    BELL_L;
			B_key();
		/** 测试直立时间**/
		/**	TIME_TEST_1;
			DMATimerGet();
	    	AngleCalculate();
			TIME_TEST_0;
			DMATimerGet();
			AngleCalculate();
			TIME_TEST_1;
			Direction_gyro = cai_z();
	    	AngleControl();
			AngleControlOutput();
			TIME_TEST_0;
			Direction_gyro = cai_z();
	    	AngleControl();
			AngleControlOutput();	
			AngleControl();
			Serial_dis();  
		 **/
		/** 测试DMA 	DMATimerGet();**/
	    	ge  	=	(int16)leftpulse % 10 		  	    + 0x30;
			shi		=	(int16)leftpulse % 100/10    		+ 0x30;
			bai		=	(int16)leftpulse % 1000/100 			+ 0x30;
			qian	=	(int16)leftpulse % 10000/1000		+ 0x30;
			wan		=	(int16)leftpulse / 10000				+ 0x30;
			uart0_putchar('-');
			uart0_putchar(wan);
		    uart0_putchar(qian);
		    uart0_putchar(bai);
		    uart0_putchar(shi);
			uart0_putchar(ge);
			uart0_putchar('\n');
		
		//	测试PWM**/
		//  PWM_left (400);		   // 左轮小于500 反转   大于500 正转	    
		//  PWM_right(400);        // 右轮小于500 反转   大于500 正转  

		/** 测试拨码开关**/
		
		
		/** 测试直立零点**/
		
		//	TIME_TEST_1;
		//	AngleCalculate();
		//	TIME_TEST_0;
		//	AngleCalculate();
	

		/**
			CCD_AN0_CLK_1;
			asm("nop");asm("nop");
			CCD_AN0_CLK_0;
			asm("nop");asm("nop");
			
			
			CCD_AN0_SI_1;
			asm("nop");asm("nop");
			CCD_AN0_SI_0;
			asm("nop");asm("nop");
			
			
			CCD_AN1_CLK_1;
			asm("nop");asm("nop");
			CCD_AN1_CLK_0;
			asm("nop");asm("nop");
			
			CCD_AN1_SI_1;
			asm("nop");asm("nop");
			CCD_AN1_SI_0;
			asm("nop");asm("nop");
		**/
























